# SPDX-License-Identifier: MIT
# Copyright (c) 2025 Blackcat InformaticsÂ® Inc.
"""Helpers for converting diagnostics and outcomes to serializable data."""

from __future__ import annotations

import json
from collections.abc import Callable, Mapping, Sequence
from collections.abc import Set as AbstractSet
from functools import cache
from pathlib import Path
from typing import TYPE_CHECKING, Protocol, TypeAlias, runtime_checkable

from pydantic import BaseModel

from pyqa.core.severity import Severity

if TYPE_CHECKING:  # pragma: no cover - typing only
    from pyqa.core.models import Diagnostic, JsonValue, ToolExitCategory, ToolOutcome


type _JsonScalar = str | int | float | bool | None
type JsonValue = _JsonScalar | list["JsonValue"] | dict[str, "JsonValue"]

SerializableMapping: TypeAlias = dict[str, JsonValue]

type _CoerceOutput = Callable[[Sequence[str] | str | JsonValue | None], list[str]]


@cache
def _model_exports() -> tuple[type[Diagnostic], type[ToolExitCategory], type[ToolOutcome], _CoerceOutput]:
    """Return core model classes without introducing import cycles."""

    from pyqa.core.models import Diagnostic, ToolExitCategory, ToolOutcome, coerce_output_sequence

    return Diagnostic, ToolExitCategory, ToolOutcome, coerce_output_sequence


@runtime_checkable
class SupportsToDict(Protocol):
    """Expose a ``to_dict`` JSON conversion hook."""

    def to_dict(self) -> SerializableValue:
        """Return a JSON-serialisable representation.

        Returns:
            SerializableValue: JSON-compatible representation of the value.
        """

    def __call__(self) -> SerializableValue:
        """Return the JSON-serialisable representation via :meth:`to_dict`.

        Returns:
            SerializableValue: JSON-compatible representation of the value.
        """

        return self.to_dict()


SerializableValue: TypeAlias = (
    JsonValue
    | Path
    | BaseModel
    | Mapping[str, "SerializableValue"]
    | Sequence["SerializableValue"]
    | AbstractSet["SerializableValue"]
    | SupportsToDict
)


def serialize_diagnostic(diag: Diagnostic) -> SerializableMapping:
    """Convert a diagnostic into a JSON-friendly mapping.

    Args:
        diag: Diagnostic emitted by a tool.

    Returns:
        SerializableMapping: Mapping suitable for JSON serialization.
    """

    return {
        "file": diag.file,
        "line": diag.line,
        "column": diag.column,
        "severity": diag.severity.value,
        "message": diag.message,
        "tool": diag.tool,
        "code": diag.code,
        "group": diag.group,
    }


def serialize_outcome(outcome: ToolOutcome) -> dict[str, JsonValue]:
    """Serialize a tool outcome including its diagnostics.

    Args:
        outcome: Tool result produced by a lint execution.

    Returns:
        dict[str, JsonValue]: JSON-compatible representation of ``outcome``.
    """

    return {
        "tool": outcome.tool,
        "action": outcome.action,
        "returncode": outcome.returncode,
        "stdout": list(outcome.stdout),
        "stderr": list(outcome.stderr),
        "diagnostics": [serialize_diagnostic(diag) for diag in outcome.diagnostics],
        "cached": outcome.cached,
        "exit_category": outcome.exit_category.value,
    }


def deserialize_outcome(data: Mapping[str, JsonValue]) -> ToolOutcome:
    """Rehydrate a :class:`ToolOutcome` from the serialized representation.

    Args:
        data: Serialized mapping previously generated by :func:`serialize_outcome`.

    Returns:
        ToolOutcome: Tool outcome reconstructed from ``data``.
    """

    Diagnostic, ToolExitCategory, ToolOutcome, coerce_output_sequence = _model_exports()

    diagnostics: list[Diagnostic] = []
    for entry in _coerce_diagnostic_payload(data.get("diagnostics")):
        severity_enum = _coerce_severity(entry.get("severity", "warning"))
        diagnostics.append(
            Diagnostic(
                file=coerce_optional_str(entry.get("file")),
                line=coerce_optional_int(entry.get("line")),
                column=coerce_optional_int(entry.get("column")),
                severity=severity_enum,
                message=str(entry.get("message", "")),
                tool=str(entry.get("tool", "")),
                code=coerce_optional_str(entry.get("code")),
                group=coerce_optional_str(entry.get("group")),
            ),
        )

    stdout_value = data.get("stdout", [])
    stderr_value = data.get("stderr", [])
    stdout_list = coerce_output_sequence(stdout_value)
    stderr_list = coerce_output_sequence(stderr_value)

    exit_category_raw = data.get("exit_category")
    exit_category = (
        _parse_exit_category(exit_category_raw) if isinstance(exit_category_raw, str) else ToolExitCategory.UNKNOWN
    )

    return ToolOutcome(
        tool=str(data.get("tool", "")),
        action=str(data.get("action", "")),
        returncode=safe_int(data.get("returncode")),
        stdout=stdout_list,
        stderr=stderr_list,
        diagnostics=diagnostics,
        cached=bool(data.get("cached", False)),
        exit_category=exit_category,
    )


def _parse_exit_category(value: str) -> ToolExitCategory:
    """Return a :class:`ToolExitCategory` derived from ``value`` with fallback.

    Args:
        value: Raw exit category string.

    Returns:
        ToolExitCategory: Parsed exit category or :class:`ToolExitCategory.UNKNOWN`.
    """

    _, ToolExitCategory, _, _ = _model_exports()
    try:
        return ToolExitCategory(value)
    except ValueError:
        return ToolExitCategory.UNKNOWN


def _coerce_severity(value: JsonValue) -> Severity:
    """Return a :class:`Severity` derived from ``value`` with fallback.

    Args:
        value: Raw severity value.

    Returns:
        Severity: Parsed severity with fallback to :class:`Severity.WARNING`.
    """

    try:
        return Severity(str(value))
    except ValueError:
        return Severity.WARNING


def safe_int(value: JsonValue, default: int = 0) -> int:
    """Return ``value`` as ``int`` when possible, otherwise ``default``.

    Args:
        value: Raw value to coerce.
        default: Fallback integer when coercion fails.

    Returns:
        int: Parsed integer or ``default``.
    """
    if isinstance(value, bool):
        return int(value)
    if isinstance(value, int):
        return value
    if isinstance(value, str):
        try:
            return int(value)
        except ValueError:
            return default
    return default


def coerce_optional_int(value: JsonValue) -> int | None:
    """Return an optional integer parsed from ``value`` when feasible.

    Args:
        value: Raw value to coerce.

    Returns:
        Optional[int]: Parsed integer when successful, otherwise ``None``.
    """
    if isinstance(value, bool):
        return int(value)
    if isinstance(value, int):
        return value
    if isinstance(value, str):
        try:
            return int(value)
        except ValueError:
            return None
    return None


def coerce_optional_str(value: JsonValue) -> str | None:
    """Return a string representation of ``value`` or ``None`` when unset.

    Args:
        value: Raw value to coerce.

    Returns:
        Optional[str]: String representation or ``None`` when unavailable.
    """
    if value is None:
        return None
    return str(value)


def _coerce_diagnostic_payload(value: JsonValue | Sequence[JsonValue] | None) -> list[SerializableMapping]:
    """Return a list of diagnostic payloads parsed from ``value``.

    Args:
        value: Raw diagnostic payload drawn from serialized outcomes.

    Returns:
        list[SerializableMapping]: Normalised diagnostic payloads.
    """

    if not isinstance(value, Sequence) or isinstance(value, (str, bytes, bytearray)):
        return []
    diagnostics: list[SerializableMapping] = []
    for item in value:
        if isinstance(item, dict):
            diagnostics.append({str(key): val for key, val in item.items()})
    return diagnostics


def jsonify(value: SerializableValue) -> JsonValue:
    """Convert ``value`` into a JSON-compatible structure.

    Args:
        value: Value produced by runtime components that must be convertible into a
            JSON-compatible representation.

    Returns:
        JsonValue: Representation that can be serialized by JSON encoders.
    """

    if value is None or isinstance(value, (str, int, float, bool)):
        return value

    if isinstance(value, Path):
        result: JsonValue = value.as_posix()
    elif isinstance(value, BaseModel):
        result = jsonify(value.model_dump(mode="python", by_alias=True))
    elif isinstance(value, SupportsToDict):
        result = jsonify(value.to_dict())
    elif isinstance(value, Mapping):
        result = {str(key): jsonify(item) for key, item in value.items()}
    elif isinstance(value, AbstractSet):
        serialised = [jsonify(item) for item in value]
        try:
            result = sorted(serialised, key=lambda item: json.dumps(item, sort_keys=True))
        except TypeError:
            result = serialised
    elif isinstance(value, Sequence) and not isinstance(value, (str, bytes, bytearray)):
        result = [jsonify(item) for item in value]
    else:
        result = str(value)

    return result


__all__ = [
    "SerializableMapping",
    "SerializableValue",
    "SupportsToDict",
    "coerce_optional_int",
    "coerce_optional_str",
    "deserialize_outcome",
    "JsonValue",
    "jsonify",
    "safe_int",
    "serialize_diagnostic",
    "serialize_outcome",
]
