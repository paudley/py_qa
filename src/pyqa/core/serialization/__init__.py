# SPDX-License-Identifier: MIT
# Copyright (c) 2025 Blackcat InformaticsÂ® Inc.
"""Helpers for converting diagnostics and outcomes to serializable data."""

from __future__ import annotations

import json
from collections.abc import Callable, Mapping, Sequence
from collections.abc import Set as AbstractSet
from pathlib import Path
from typing import TypeAlias, cast

from pyqa.core.models import Diagnostic, ToolExitCategory, ToolOutcome, coerce_output_sequence
from pyqa.core.severity import Severity
from pyqa.interfaces.core import JsonValue
from pyqa.interfaces.reporting import DiagnosticView, ToolOutcomeView
from pyqa.interfaces.serialization import SerializableMapping, SerializableValue, SupportsModelDump, SupportsToDict

DiagnosticLike: TypeAlias = Diagnostic | DiagnosticView
OutcomeLike: TypeAlias = ToolOutcome | ToolOutcomeView

DiagnosticFactory = Callable[..., Diagnostic]
OutcomeFactory = Callable[..., ToolOutcome]


def serialize_diagnostic(diag: DiagnosticLike) -> SerializableMapping:
    """Convert a diagnostic into a JSON-friendly mapping.

    Args:
        diag: Diagnostic emitted by a tool.

    Returns:
        SerializableMapping: Mapping suitable for JSON serialization.
    """

    return {
        "file": diag.file,
        "line": diag.line,
        "column": diag.column,
        "severity": diag.severity.value,
        "message": diag.message,
        "tool": diag.tool,
        "code": diag.code,
        "group": diag.group,
    }


def serialize_outcome(outcome: OutcomeLike) -> dict[str, JsonValue]:
    """Serialize a tool outcome including its diagnostics.

    Args:
        outcome: Tool result produced by a lint execution.

    Returns:
        dict[str, JsonValue]: JSON-compatible representation of ``outcome``.
    """

    stdout_payload: list[JsonValue] = [str(line) for line in outcome.stdout]
    stderr_payload: list[JsonValue] = [str(line) for line in outcome.stderr]
    diagnostics_payload: list[JsonValue] = [
        cast(JsonValue, dict(serialize_diagnostic(diag))) for diag in outcome.diagnostics
    ]

    return {
        "tool": outcome.tool,
        "action": outcome.action,
        "returncode": outcome.returncode,
        "stdout": stdout_payload,
        "stderr": stderr_payload,
        "diagnostics": diagnostics_payload,
        "cached": outcome.cached,
        "exit_category": outcome.exit_category.value,
    }


def deserialize_outcome(
    data: Mapping[str, JsonValue],
    *,
    diagnostic_factory: DiagnosticFactory = Diagnostic,
    outcome_factory: OutcomeFactory = ToolOutcome,
) -> ToolOutcome:
    """Rehydrate a :class:`ToolOutcome` from the serialized representation.

    Args:
        data: Serialized mapping previously generated by :func:`serialize_outcome`.
        diagnostic_factory: Optional factory used to build diagnostics.
        outcome_factory: Optional factory used to build the outcome aggregate.

    Returns:
        ToolOutcome: Tool outcome reconstructed from ``data``.
    """

    diagnostics: list[Diagnostic] = []
    for entry in _coerce_diagnostic_payload(data.get("diagnostics")):
        severity_enum = _coerce_severity(entry.get("severity", "warning"))
        diagnostics.append(
            diagnostic_factory(
                file=coerce_optional_str(entry.get("file")),
                line=coerce_optional_int(entry.get("line")),
                column=coerce_optional_int(entry.get("column")),
                severity=severity_enum,
                message=str(entry.get("message", "")),
                tool=str(entry.get("tool", "")),
                code=coerce_optional_str(entry.get("code")),
                group=coerce_optional_str(entry.get("group")),
            ),
        )

    stdout_value = data.get("stdout", [])
    stderr_value = data.get("stderr", [])
    stdout_list = coerce_output_sequence(stdout_value)
    stderr_list = coerce_output_sequence(stderr_value)

    exit_category_raw = data.get("exit_category")
    exit_category = (
        _parse_exit_category(exit_category_raw) if isinstance(exit_category_raw, str) else ToolExitCategory.UNKNOWN
    )

    return outcome_factory(
        tool=str(data.get("tool", "")),
        action=str(data.get("action", "")),
        returncode=safe_int(data.get("returncode")),
        stdout=stdout_list,
        stderr=stderr_list,
        diagnostics=diagnostics,
        cached=bool(data.get("cached", False)),
        exit_category=exit_category,
    )


def _parse_exit_category(value: str) -> ToolExitCategory:
    """Return a :class:`ToolExitCategory` derived from ``value`` with fallback.

    Args:
        value: Raw exit category string.

    Returns:
        ToolExitCategory: Parsed exit category or :class:`ToolExitCategory.UNKNOWN`.
    """

    try:
        return ToolExitCategory(value)
    except ValueError:
        return ToolExitCategory.UNKNOWN


def _coerce_severity(value: JsonValue) -> Severity:
    """Return a :class:`Severity` derived from ``value`` with fallback.

    Args:
        value: Raw severity value.

    Returns:
        Severity: Parsed severity with fallback to :class:`Severity.WARNING`.
    """

    try:
        return Severity(str(value))
    except ValueError:
        return Severity.WARNING


def safe_int(value: JsonValue, default: int = 0) -> int:
    """Return ``value`` as ``int`` when possible, otherwise ``default``.

    Args:
        value: Raw value to coerce.
        default: Fallback integer when coercion fails.

    Returns:
        int: Parsed integer or ``default``.
    """
    if isinstance(value, bool):
        return int(value)
    if isinstance(value, int):
        return value
    if isinstance(value, str):
        try:
            return int(value)
        except ValueError:
            return default
    return default


def coerce_optional_int(value: JsonValue) -> int | None:
    """Return an optional integer parsed from ``value`` when feasible.

    Args:
        value: Raw value to coerce.

    Returns:
        int | None: Parsed integer when successful, otherwise ``None``.
    """
    if isinstance(value, bool):
        return int(value)
    if isinstance(value, int):
        return value
    if isinstance(value, str):
        try:
            return int(value)
        except ValueError:
            return None
    return None


def coerce_optional_str(value: JsonValue) -> str | None:
    """Return a string representation of ``value`` or ``None`` when unset.

    Args:
        value: Raw value to coerce.

    Returns:
        str | None: String representation or ``None`` when unavailable.
    """
    if value is None:
        return None
    return str(value)


def _coerce_diagnostic_payload(value: JsonValue | Sequence[JsonValue] | None) -> list[SerializableMapping]:
    """Return a list of diagnostic payloads parsed from ``value``.

    Args:
        value: Raw diagnostic payload drawn from serialized outcomes.

    Returns:
        list[SerializableMapping]: Normalised diagnostic payloads.
    """

    if not isinstance(value, Sequence) or isinstance(value, (str, bytes, bytearray)):
        return []
    diagnostics: list[SerializableMapping] = []
    for item in value:
        if isinstance(item, dict):
            diagnostics.append({str(key): val for key, val in item.items()})
    return diagnostics


def jsonify(value: SerializableValue) -> JsonValue:
    """Convert ``value`` into a JSON-compatible structure.

    Args:
        value: Value produced by runtime components that must be convertible into a
            JSON-compatible representation.

    Returns:
        JsonValue: Representation that can be serialized by JSON encoders.
    """

    if value is None or isinstance(value, (str, int, float, bool)):
        return value

    if isinstance(value, Path):
        result: JsonValue = value.as_posix()
    elif isinstance(value, SupportsModelDump):
        result = jsonify(value.model_dump(mode="python", by_alias=True))
    elif isinstance(value, SupportsToDict):
        result = jsonify(value.to_dict())
    elif isinstance(value, Mapping):
        result = {str(key): jsonify(item) for key, item in value.items()}
    elif isinstance(value, AbstractSet):
        serialised = [jsonify(item) for item in value]
        try:
            result = sorted(serialised, key=lambda item: json.dumps(item, sort_keys=True))
        except TypeError:
            result = serialised
    elif isinstance(value, Sequence) and not isinstance(value, (str, bytes, bytearray)):
        result = [jsonify(item) for item in value]
    else:
        result = str(value)

    return result


__all__ = [
    "SerializableMapping",
    "SerializableValue",
    "SupportsToDict",
    "coerce_optional_int",
    "coerce_optional_str",
    "deserialize_outcome",
    "JsonValue",
    "jsonify",
    "safe_int",
    "serialize_diagnostic",
    "serialize_outcome",
]
