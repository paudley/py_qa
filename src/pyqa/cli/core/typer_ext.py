# SPDX-License-Identifier: MIT
# Copyright (c) 2025 Blackcat InformaticsÂ® Inc.
"""Custom Typer helpers for consistent, sorted CLI help output."""

from __future__ import annotations

import inspect
from collections.abc import Callable, Iterable, Mapping, Sequence
from dataclasses import dataclass
from functools import partial
from types import EllipsisType, GenericAlias, UnionType
from typing import (
    Annotated,
    Final,
    Protocol,
    TypeAlias,
    TypeVar,
    cast,
    get_args,
    get_origin,
    get_type_hints,
)

import click
import typer
import typer.main
from click.core import Argument, Context, Option, Parameter
from click.formatting import HelpFormatter
from typer.core import TyperCommand, TyperGroup
from typer.models import OptionInfo, ParameterInfo, ParamMeta

from .shared import (
    CommandCallable,
    CommandResult,
    Depends,
)


class CLIParameterValue(Protocol):
    """Marker protocol for values exchanged through Typer callbacks."""


CLIConvertor: TypeAlias = Callable[[CLIParameterValue], CLIParameterValue]
ConvertorMap: TypeAlias = dict[str, CLIConvertor]
DefaultsMap: TypeAlias = dict[str, CLIParameterValue]
AnnotationValue: TypeAlias = type | GenericAlias | UnionType | tuple[type, ...] | str | EllipsisType | None
AnnotationMap: TypeAlias = Mapping[str, AnnotationValue]
ParamsMetadata: TypeAlias = tuple[list[Argument | Option], ConvertorMap, str | None]
TyperParamShim: TypeAlias = Callable[..., ParamsMetadata]
TyperCallbackShim: TypeAlias = Callable[..., Callable[..., CLIParameterValue] | None]
DependencyCallable: TypeAlias = Callable[..., CLIParameterValue]
AnalyzableCallable: TypeAlias = Callable[..., CLIParameterValue]
GetClickParamCallable: TypeAlias = Callable[[ParamMeta], tuple[Argument | Option, CLIConvertor | None]]


@dataclass(slots=True)
class _DependencyMeta:
    param_name: str
    dependency: DependencyCallable
    cli_param_names: set[str]
    context_param_name: str | None
    defaults: DefaultsMap


@dataclass(slots=True)
class _AnalyzedCallback:
    """Capture Typer callback metadata required to build Click parameters."""

    params: list[Argument | Option]
    convertors: ConvertorMap
    context_param_name: str | None
    dependencies: list[_DependencyMeta]
    cli_param_names: set[str]
    defaults: DefaultsMap


@dataclass(slots=True)
class _DependencyInvocation:
    """Invoke callbacks with dependency context and preserved convertors."""

    resolver: _DependencyResolver
    callback: CommandCallable
    analysis: _AnalyzedCallback
    defaults: DefaultsMap
    convertors: ConvertorMap

    # suppression_valid: lint=internal-signatures Typer callback wrapper must expose the dynamic call signature expected by Typer while routing through our resolver.
    def __call__(self, *call_args: CLIParameterValue, **kwargs: CLIParameterValue) -> CommandResult:
        """Execute ``callback`` using resolver-managed dependency injection.

        Args:
            *call_args: Positional arguments forwarded by Typer (context only).
            **kwargs: Keyword arguments forwarded to the callback.

        Returns:
            CommandResult: Value produced by the wrapped callback.
        """

        context = cast(click.Context, call_args[0] if call_args else click.get_current_context())
        params: DefaultsMap = dict(kwargs)
        plan = self.resolver.InvocationPlan(
            analysis=self.analysis,
            defaults=self.defaults,
            convertors=self.convertors,
            context=context,
            params=params,
        )
        return self.resolver.invoke(self.callback, plan)


@dataclass(slots=True)
class _AnalysisState:
    """Mutable state accumulated while analysing a callback."""

    params: list[Argument | Option]
    convertors: ConvertorMap
    dependencies: list[_DependencyMeta]
    cli_param_names: set[str]
    context_param_name: str | None
    defaults: DefaultsMap


@dataclass(slots=True)
class _DirectParameterContext:
    """Container describing a direct parameter without dependency metadata."""

    parameter: inspect.Parameter
    annotation: AnnotationValue
    parameter_info: ParameterInfo | None


ARGUMENT_PARAM_TYPE: Final[str] = "argument"


def _sanitize_param_decl(
    param: ParamMeta,
    *,
    original_get_click_param: GetClickParamCallable,
) -> tuple[Argument | Option, CLIParameterValue]:
    """Strip non-string parameter declarations before delegating to Typer.

    Args:
        param: Parameter metadata generated by Typer.
        original_get_click_param: Typer helper used to generate Click parameters.

    Returns:
        tuple[Argument | Option, CLIConvertor | None]: Click parameter pair produced by Typer.
    """

    param_decls = getattr(param.default, "param_decls", None)
    if isinstance(param_decls, Sequence):
        sanitized = tuple(decl for decl in param_decls if isinstance(decl, str))
        if len(sanitized) != len(param_decls):
            setattr(param.default, "param_decls", sanitized)
    click_param, raw_convertor = original_get_click_param(param)
    convertor: CLIConvertor | None = raw_convertor if callable(raw_convertor) else None
    return click_param, convertor


@dataclass(frozen=True)
class _ParamSanitizer:
    """Callable wrapper that normalises Typer parameter declarations."""

    original: GetClickParamCallable

    def __call__(self, param: ParamMeta) -> tuple[Argument | Option, CLIParameterValue]:
        """Sanitise ``param`` before delegating to the original Click factory."""

        return _sanitize_param_decl(param, original_get_click_param=self.original)


def _dependency_param_adapter(
    callback: AnalyzableCallable | None,
    *,
    resolver: _DependencyResolver,
) -> ParamsMetadata:
    """Return analyzer-backed Typer parameter metadata for ``callback``.

    Args:
        callback: Callback under analysis.
        resolver: Resolver providing dependency metadata caches.

    Returns:
        ParamsMetadata: Parameter metadata consumed by Typer.
    """

    if callback is None:
        return [], dict[str, CLIConvertor](), None
    analysis = resolver.analyze(callback)
    return (
        analysis.params,
        analysis.convertors,
        analysis.context_param_name,
    )


# suppression_valid: lint=internal-signatures adapter must mirror Typer's callback factory signature to intercept dependency resolution without breaking upstream expectations.
def _dependency_callback_adapter(
    *,
    callback: AnalyzableCallable | None = None,
    params: Sequence[inspect.Parameter] = (),
    convertors: ConvertorMap | None = None,
    context_param_name: str | None = None,
    pretty_exceptions_short: bool,
    resolver: _DependencyResolver,
) -> CommandCallable | None:
    """Build a dependency-aware Typer callback wrapper.

    Args:
        callback: Callback to wrap.
        params: Original Typer parameters (unused; retained for compatibility).
        convertors: Optional mapping of parameter convertors.
        context_param_name: Optional context parameter name reported by Typer.
        pretty_exceptions_short: Whether Typer is using abbreviated exceptions.
        resolver: Resolver orchestrating dependency injection.

    Returns:
        CommandCallable | None: Wrapped callback or ``None`` when no callback is provided.
    """

    if callback is None:
        return None
    del params, context_param_name, pretty_exceptions_short
    analysis = resolver.analyze(callback)
    defaults = dict(analysis.defaults)
    defaults.update(resolver.build_default_values(callback))
    use_convertors: ConvertorMap = dict(analysis.convertors)
    if convertors:
        use_convertors.update(convertors)
    wrapped_callback = cast(CommandCallable, callback)
    return _DependencyInvocation(
        resolver=resolver,
        callback=wrapped_callback,
        analysis=analysis,
        defaults=defaults,
        convertors=use_convertors,
    )


def _install_param_decl_sanitizer() -> None:
    """Install a guard that strips non-string parameter declarations.

    Returns:
        None: The guard is installed as a side effect on :mod:`typer.main`.

    """

    if getattr(typer.main, "_pyqa_param_sanitizer_installed", False):
        return

    original_get_click_param = cast(GetClickParamCallable, typer.main.get_click_param)
    sanitizer = _ParamSanitizer(original=original_get_click_param)
    sanitizer_callable = cast(GetClickParamCallable, sanitizer)
    setattr(typer.main, "get_click_param", sanitizer_callable)
    setattr(typer.main, "_pyqa_param_sanitizer_installed", True)

    _install_dependency_support(original_get_click_param)


def _install_dependency_support(
    original_get_click_param: GetClickParamCallable,
) -> None:
    """Install dependency-aware Typer patches to support nested callbacks.

    Args:
        original_get_click_param: Typer helper used to translate parameters into
            Click objects prior to installing the dependency-aware shim.

    """

    if getattr(typer.main, "_pyqa_dependency_support_installed", False):
        return

    resolver = _DependencyResolver(original_get_click_param)
    param_adapter: TyperParamShim = _build_dependency_param_adapter(resolver)
    callback_adapter: TyperCallbackShim = _build_dependency_callback_adapter(resolver)
    typer.main.get_params_convertors_ctx_param_name_from_function = param_adapter
    typer.main.get_callback = callback_adapter
    setattr(typer.main, "_pyqa_dependency_support_installed", True)


def _build_dependency_param_adapter(
    resolver: _DependencyResolver,
) -> TyperParamShim:
    """Return a Typer helper that exposes dependency-aware parameter metadata."""

    return partial(_dependency_param_adapter, resolver=resolver)


def _build_dependency_callback_adapter(
    resolver: _DependencyResolver,
) -> TyperCallbackShim:
    """Return a Typer helper that wires dependency resolution into callbacks."""

    return partial(_dependency_callback_adapter, resolver=resolver)


class _DependencyResolver:
    """Analyse Typer callbacks and resolve nested dependencies lazily."""

    def __init__(
        self,
        original_get_click_param: GetClickParamCallable,
    ) -> None:
        self._get_click_param = original_get_click_param

    # Public API ------------------------------------------------------------------

    def analyze(self, callback: AnalyzableCallable | None) -> _AnalyzedCallback:
        """Return analysis metadata for ``callback`` reusing cached results."""

        if callback is None:
            return _AnalyzedCallback(
                [],
                dict[str, CLIConvertor](),
                None,
                [],
                set(),
                dict[str, CLIParameterValue](),
            )
        cached: _AnalyzedCallback | None = getattr(callback, "__pyqa_analysis__", None)
        if cached is not None:
            return cached

        analysis = self._build_analysis(callback)
        self._cache_analysis(callback, analysis)
        return analysis

    def resolve(
        self,
        callback: AnalyzableCallable,
        values: DefaultsMap,
        context: click.Context,
    ) -> None:
        """Resolve dependency outputs for ``callback`` and populate ``values``."""

        analysis = self.analyze(callback)
        for meta in analysis.dependencies:
            dep_values = self._extract_dependency_values(values, meta, context)
            self.resolve(meta.dependency, dep_values, context)
            sig = inspect.signature(meta.dependency)
            call_kwargs = {name: dep_values[name] for name in sig.parameters if name in dep_values}
            result = meta.dependency(**call_kwargs)
            values[meta.param_name] = result

    @dataclass(slots=True)
    class InvocationPlan:
        """Describe resolved parameters required to invoke a callback."""

        analysis: _AnalyzedCallback
        defaults: DefaultsMap
        convertors: ConvertorMap
        context: click.Context
        params: DefaultsMap

    def invoke(self, callback: CommandCallable, plan: InvocationPlan) -> CommandResult:
        """Invoke ``callback`` with dependency-aware argument resolution."""

        values: DefaultsMap = dict(plan.defaults)
        for key, value in plan.params.items():
            if key in plan.convertors:
                if value is None:
                    continue
                values[key] = plan.convertors[key](value)
                continue
            if value is not None:
                values[key] = value
            else:
                values[key] = values.get(key)
        if plan.analysis.context_param_name:
            values[plan.analysis.context_param_name] = plan.context
        self.resolve(callback, values, plan.context)
        call_signature = inspect.signature(callback)
        call_kwargs: DefaultsMap = {name: values[name] for name in call_signature.parameters if name in values}
        return callback(**call_kwargs)

    # Internal helpers ------------------------------------------------------------

    def _build_analysis(self, callback: AnalyzableCallable) -> _AnalyzedCallback:
        signature = inspect.signature(callback)
        type_hints = self._safe_type_hints(callback)

        state = _AnalysisState(
            params=[],
            convertors=dict[str, CLIConvertor](),
            dependencies=[],
            cli_param_names=set(),
            context_param_name=None,
            defaults=dict[str, CLIParameterValue](),
        )

        for param_name, parameter in signature.parameters.items():
            self._process_parameter(
                param_name=param_name,
                parameter=parameter,
                type_hints=type_hints,
                state=state,
            )

        return _AnalyzedCallback(
            params=state.params,
            convertors=state.convertors,
            context_param_name=state.context_param_name,
            dependencies=state.dependencies,
            cli_param_names=state.cli_param_names,
            defaults=state.defaults,
        )

    def _cache_analysis(self, callback: AnalyzableCallable, analysis: _AnalyzedCallback) -> None:
        """Persist ``analysis`` on ``callback`` for subsequent invocations."""

        setattr(callback, "__pyqa_analysis__", analysis)
        setattr(callback, "__pyqa_params__", analysis.params)
        setattr(callback, "__pyqa_convertors__", analysis.convertors)
        setattr(callback, "__pyqa_context_param__", analysis.context_param_name)
        setattr(callback, "__pyqa_dependencies__", analysis.dependencies)
        setattr(callback, "__pyqa_cli_param_names__", analysis.cli_param_names)
        setattr(callback, "__pyqa_analyzed__", True)

    def _safe_type_hints(self, callback: AnalyzableCallable) -> dict[str, AnnotationValue]:
        """Return type hints for ``callback`` handling failures defensively."""

        try:
            return get_type_hints(callback, include_extras=True)
        except (
            AttributeError,
            NameError,
            TypeError,
            ValueError,
        ):  # pragma: no cover - defensive fallback
            return dict[str, AnnotationValue]()

    def _parse_annotation(
        self,
        annotation: AnnotationValue,
        parameter: inspect.Parameter,
    ) -> tuple[AnnotationValue, ParameterInfo | None, Depends[CLIParameterValue] | None]:
        """Return resolved annotation metadata for ``parameter``."""

        dependency_info: Depends[CLIParameterValue] | None = None
        parameter_info: ParameterInfo | None = None
        if annotation is inspect.Signature.empty:
            annotation = str
        origin = get_origin(annotation)
        if origin is Annotated:
            base, *metadata = get_args(annotation)
            annotation = base
            for meta in metadata:
                if isinstance(meta, Depends):
                    dependency_info = meta
                elif isinstance(meta, ParameterInfo):
                    parameter_info = meta
        if isinstance(parameter.default, ParameterInfo) and parameter_info is None:
            parameter_info = parameter.default
        return annotation, parameter_info, dependency_info

    def _is_context_parameter(self, annotation: AnnotationValue) -> bool:
        """Return ``True`` when ``annotation`` requests a Click context."""

        return isinstance(annotation, type) and issubclass(annotation, click.Context)

    def _build_click_parameter(
        self,
        parameter: inspect.Parameter,
        annotation: AnnotationValue,
        parameter_info: ParameterInfo | None,
    ) -> tuple[Argument | Option, CLIConvertor | None]:
        """Return the Click parameter + convertor for Typer metadata."""

        info = parameter_info or OptionInfo()
        updated_parameter = parameter.replace(annotation=annotation, default=info)
        param_meta = ParamMeta(
            name=updated_parameter.name,
            default=updated_parameter.default,
            annotation=updated_parameter.annotation,
        )
        click_param, convertor_value = self._get_click_param(param_meta)
        return click_param, convertor_value

    def _extract_dependency_values(
        self,
        values: DefaultsMap,
        meta: _DependencyMeta,
        context: click.Context,
    ) -> DefaultsMap:
        """Return values mapped to ``meta`` while removing them from ``values``."""

        dep_values: DefaultsMap = dict[str, CLIParameterValue]()
        for name in meta.cli_param_names:
            if name in values:
                dep_values[name] = values.pop(name)
                continue
            if name in meta.defaults:
                dep_values[name] = meta.defaults[name]
                continue
            dep_values[name] = None
        if meta.context_param_name:
            dep_values[meta.context_param_name] = context
        return dep_values

    def build_default_values(self, callback: AnalyzableCallable) -> DefaultsMap:
        """Return default parameter values derived from ``callback`` signature."""

        defaults: DefaultsMap = dict[str, CLIParameterValue]()
        signature = inspect.signature(callback)
        for name, parameter in signature.parameters.items():
            default_candidate = parameter.default
            if isinstance(default_candidate, ParameterInfo):
                defaults[name] = getattr(default_candidate, "default", None)
            elif default_candidate is inspect.Signature.empty:
                defaults[name] = None
            else:
                defaults[name] = default_candidate
        return defaults

    def _process_parameter(
        self,
        *,
        param_name: str,
        parameter: inspect.Parameter,
        type_hints: AnnotationMap,
        state: _AnalysisState,
    ) -> None:
        """Analyse a single parameter and update analysis state."""

        annotation = type_hints.get(param_name, parameter.annotation)
        annotation, parameter_info, dependency_info = self._parse_annotation(annotation, parameter)

        if self._is_context_parameter(annotation):
            if state.context_param_name is None:
                state.context_param_name = param_name
            return

        if dependency_info is not None:
            self._add_dependency_parameter(
                param_name=param_name,
                dependency_callable=dependency_info.dependency,
                state=state,
            )
            return

        self._add_direct_parameter(
            param_name=param_name,
            context=_DirectParameterContext(
                parameter=parameter,
                annotation=annotation,
                parameter_info=parameter_info,
            ),
            state=state,
        )

    def _add_dependency_parameter(
        self,
        *,
        param_name: str,
        dependency_callable: DependencyCallable,
        state: _AnalysisState,
    ) -> None:
        """Register dependency metadata for ``param_name``."""

        dep_analysis = self.analyze(dependency_callable)
        state.params.extend(dep_analysis.params)
        state.convertors.update(dep_analysis.convertors)
        meta_defaults: DefaultsMap = {name: dep_analysis.defaults.get(name) for name in dep_analysis.cli_param_names}
        state.dependencies.append(
            _DependencyMeta(
                param_name=param_name,
                dependency=dependency_callable,
                cli_param_names=set(dep_analysis.cli_param_names),
                context_param_name=dep_analysis.context_param_name,
                defaults=meta_defaults,
            )
        )
        state.cli_param_names.update(dep_analysis.cli_param_names)

    def _add_direct_parameter(
        self,
        *,
        param_name: str,
        context: _DirectParameterContext,
        state: _AnalysisState,
    ) -> None:
        """Register a direct CLI parameter without dependencies.

        Args:
            param_name: Name of the CLI parameter.
            context: Metadata describing the Typer parameter declaration.
            state: Accumulated analysis state for the callback.

        """

        click_param, convertor = self._build_click_parameter(
            context.parameter,
            context.annotation,
            context.parameter_info,
        )
        state.params.append(click_param)
        if convertor:
            state.convertors[param_name] = convertor
        state.cli_param_names.add(param_name)
        if hasattr(click_param, "default"):
            default_value = getattr(click_param, "default")
            state.defaults[param_name] = cast(CLIParameterValue, default_value)


class SortedTyperCommand(TyperCommand):
    """Typer command that renders options in sorted order within help output."""

    def format_options(
        self,
        ctx: Context,
        formatter: HelpFormatter,
    ) -> None:
        """Render positional arguments and sorted options within CLI help.

        Args:
            ctx: Click context describing the application invocation.
            formatter: Click help formatter used to emit definition lists.
        """

        argument_records: list[tuple[str, str]] = []
        option_entries: list[tuple[tuple[str, int], tuple[str, str]]] = []

        for index, param in enumerate(self.get_params(ctx)):
            record = cast(tuple[str, str] | None, param.get_help_record(ctx))
            if record is None:
                continue
            if getattr(param, "param_type_name", "") == ARGUMENT_PARAM_TYPE:
                argument_records.append(record)
                continue
            option_entries.append(((_primary_option_name(param), index), record))

        if argument_records:
            with formatter.section("Arguments"):
                formatter.write_dl(argument_records)

        if option_entries:
            sorted_entries = sorted(option_entries, key=lambda item: item[0])
            sorted_records = [entry for _, entry in sorted_entries]
            with formatter.section("Options"):
                formatter.write_dl(sorted_records)


class SortedTyperGroup(TyperGroup):
    """Typer group that defaults to using :class:`SortedTyperCommand`."""

    command_class = SortedTyperCommand


CommandCallback = TypeVar("CommandCallback", bound=CommandCallable)


@dataclass(frozen=True)
class TyperAppConfig:
    """Configuration payload used when constructing :class:`SortedTyper`."""

    name: str | None = None
    help_text: str | None = None
    invoke_without_command: bool = False
    no_args_is_help: bool = False


class SortedTyper(typer.Typer):
    """Typer application that emits sorted option listings by default."""

    def __init__(self, config: TyperAppConfig | None = None, *, group_cls: type[TyperGroup] | None = None) -> None:
        """Initialise the Typer application with sorted help semantics."""

        cfg = config or TyperAppConfig()
        final_cls = group_cls or SortedTyperGroup
        super().__init__(
            name=cfg.name,
            help=cfg.help_text,
            cls=final_cls,
            invoke_without_command=cfg.invoke_without_command,
            no_args_is_help=cfg.no_args_is_help,
        )


# suppression_valid: lint=internal-signatures factory intentionally forwards arbitrary kwargs to maintain Typer compatibility while enforcing sorted command help.
def create_typer(
    *,
    config: TyperAppConfig | None = None,
    group_cls: type[TyperGroup] | None = None,
) -> SortedTyper:
    """Return a :class:`SortedTyper` configured to emit sorted help listings.

    Args:
        config: Optional application configuration payload.
        group_cls: Optional Typer group subclass to override the default sorted group.

    Returns:
        SortedTyper: Configured Typer application with sorted help output.

    """
    return SortedTyper(config=config, group_cls=group_cls)


def _primary_option_name(param: Parameter) -> str:
    """Return the canonical name used for sorting a Click parameter.

    Args:
        param: Click parameter being inspected.

    Returns:
        str: Normalised option name (without leading dashes) for sorting.

    """
    option_names: Iterable[str] = tuple(getattr(param, "opts", ())) + tuple(
        getattr(param, "secondary_opts", ()),
    )
    long_names = [name for name in option_names if name.startswith("--")]
    candidate = long_names[0] if long_names else (next(iter(option_names), "") or param.name or "")
    return candidate.lstrip("-").lower()


_install_param_decl_sanitizer()
